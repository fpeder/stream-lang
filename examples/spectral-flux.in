// Spectral flux

// A couple constants:

A = 1.0;
K = 1000;

// TODO: Return the larger of arguments. Requires conditional expression.
// For now, 'max' is a built-in function.
// max(a, b) = ?;

// Standard helper:
sum( X ) =
  reduce( a, b in X ) a + b;

// S is an individual specturm. It has only 1 dimension - each bin.
// Assuming 'log' is a built-in function that computes logarithm of a single value.
log_spectrum(S, a, k) = for each( bin in S ) {
  //log(a + k * bin)
  a + k * bin
};

// X is same as for 'flux' below
inter_spectrum_difference(X) =
  // Iterate over dimension 1 (implicitly) of X (spectrums),
  // 2 by 2 items, advancing by 1 item only
  for each( spectrum_pair takes 2 every 1 in X )
  {
    let bin_increases =
      // Iterate over dimension 2 (bins) of each pair of spectrums,
      // producing pairs of corresponding bins from 2 spectrums:
      for each( bin_pair in spectrum_pair{2} )
      {
        // Either a positive change or 0:
        //max(0, bin_pair[2] - bin_pair[1])
        bin_pair[2] - bin_pair[1]
      };

    // Sum all positive changes among corresponding bins of 2 spectrums:
    sum ( bin_increases )
  }
;

// X is a sequence of spectrums - it has 2 dimensions:
// - dimension #1 = each spectrum
// - dimension #2 = each bin of a spectrum
flux(X) = inter_spectrum_difference(
  // Iterate over (implicitly) first dimension of X:
  for each( S in X ) { log_spectrum(S,A,K) }
);
